package a2t.aos;

import com.google.gson.Gson;
import com.mongodb.MongoClient;
import com.mongodb.MongoClientURI;
import com.mongodb.client.MongoCursor;
import com.mongodb.client.MongoDatabase;
import com.mongodb.client.MongoIterable;
import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.core.config.Configurator;
import org.bson.Document;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Field;
import java.net.URLEncoder;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;
import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.stream.Collectors;

import static java.lang.System.exit;

public class ParseAOS {

    private static final Logger logger = LogManager.getLogger(ParseAOS.class);
    private static final String propFile = "aos.properties";
    private static final String tblLineFilter = "tbl";
    private static final Gson gson = new Gson();
    private static MongoDatabase db;
    private static int recordsProcessed = 0, totalRecordsProcessed = 0, filesFound = 0;

    public void runImport() throws JAXBException, IOException, NoSuchFieldException, IllegalAccessException {

        setLogLevel();

        if (db == null)
            initDB();

        if (!getProps().getProperty("aos.mongo.test").equalsIgnoreCase("true")) {
            File[] files = getFileListing(getProps().getProperty("aos.dirPath"));
            for (File file : files) {
                logger.info("XML Files Processed: {}, Out of: {}", () -> (filesFound++), () -> files.length);
                parse(file);
            }
        }
    }

    private void parse(File file) throws JAXBException, NoSuchFieldException, IllegalAccessException {
        // Replace Object with "Replace-with-Top-Level-XSD" object generated by POM.xml file.
        // JAXBContext jaxbContext = JAXBContext.newInstance(GfmDocument.class);
        JAXBContext jaxbContext = JAXBContext.newInstance(Object.class);
        Unmarshaller jaxbUnmarshaller = jaxbContext.createUnmarshaller();
        jaxbUnmarshaller.setEventHandler(
                event -> {
                    throw new RuntimeException(event.getMessage(),
                            event.getLinkedException());
                }
        );

        // Replace Object with "Replace-with-Top-Level-XSD" object generated by POM.xml file.
        //Object gfmDocument = (Object.class) jaxbUnmarshaller.unmarshal(file);
        // GfmDocument gfmDocument = (GfmDocument) jaxbUnmarshaller.unmarshal(file);
        Object gfmDocument = (Object) jaxbUnmarshaller.unmarshal(file);

        // Replace Object with the "Replace-with-Top-Level-XSD" supporting document generated by POM.xml file.
        // GFMIEDM37Type gfmiedm37Type = gfmDocument.getGFMIEDM37();
        Object gfmiedm37Type = gfmDocument.getClass();

        Field[] typeDeclaredFields = gfmiedm37Type.getClass().getDeclaredFields();
        List<String> typeFieldNames = getFieldNames(typeDeclaredFields);

        List<String> tblFields = typeFieldNames.stream()
                .filter(line -> line.contains(tblLineFilter))
                .collect(Collectors.toList());

        logger.info("Tables: {}", () -> Arrays.toString(tblFields.toArray()));
        for (String tblName : tblFields) {
            Field tblField = gfmiedm37Type.getClass().getDeclaredField(tblName);
            tblField.setAccessible(true);
            Object tblObject = tblField.get(gfmiedm37Type);
            if (tblObject != null) {
                logger.info("Table Name: {}", () -> tblName);
                Field[] declaredFields = tblObject.getClass().getDeclaredFields();
                List<String> fieldNames = getFieldNames(declaredFields);
                logger.info("Field Names: {} ", () -> Arrays.toString(fieldNames.toArray()));

                Field field = tblObject.getClass().getDeclaredField(fieldNames.get(0));
                field.setAccessible(true);
                Object fieldObject = field.get(tblObject);

                if (fieldObject instanceof java.util.ArrayList) {
                    recordsProcessed = 0;
                    for (Object fieldDocumentObject : Collections.unmodifiableList((ArrayList<Object>) fieldObject)) {
                        String jsonString = gson.toJson(fieldDocumentObject);
                        logger.debug("Add Document: {}", () -> tblName + "/" + field.getName() + " -- " + jsonString);
                        Document document = Document.parse(jsonString);
                        db.getCollection(tblName).insertOne(document);
                        if ((recordsProcessed % 500) == 0) {
                            logger.info("Documents Processed: {}, Total Processed: {}", () -> recordsProcessed, () -> totalRecordsProcessed);
                        }
                        recordsProcessed++;
                        totalRecordsProcessed++;
                    }
                } else {
                    logger.error("NOT ARRAY EXIT {}", fieldObject::getClass);
                    exit(1);
                }
            }
        }
    }

    private void initDB() throws UnsupportedEncodingException {
        String mongoUri = "mongodb://"
                + getProps().getProperty("aos.mongo.user") + ":"
                + URLEncoder.encode(getProps().getProperty("aos.mongo.pass"), "UTF-8") + "@"
                + getProps().getProperty("aos.mongo.host") + ":"
                + getProps().getProperty("aos.mongo.port") + "/"
                + getProps().getProperty("aos.mongo.dbName");
        MongoClient mongo_client = new MongoClient(new MongoClientURI(mongoUri));
        db = mongo_client.getDatabase(getProps().getProperty("aos.mongo.dbName"));

        if (getProps().getProperty("aos.mongo.test").equalsIgnoreCase("true"))
            testDbConnection(mongoUri);
    }

    private void testDbConnection(String mongoUri) {
        logger.info("Mongo Connection: {}", () -> mongoUri);
        MongoIterable<String> colls = db.listCollectionNames();
        for (String s : colls) {
            logger.info("Collection: {}", () -> s);
        }
    }

    private File[] getFileListing(String dir) {
        return new File(dir).listFiles();
    }

    private List<String> getFieldNames(Field[] fields) {
        List<String> fieldNames = new ArrayList<String>();
        for (Field field : fields)
            fieldNames.add(field.getName());
        return fieldNames;
    }

    private void setLogLevel() {
        if (getProps().getProperty("aos.log.level").equalsIgnoreCase("debug")) {
            Configurator.setAllLevels(LogManager.getRootLogger().getName(), Level.DEBUG);
        }
    }

    private static Properties getProps() {
        Properties prop = new Properties();
        try (InputStream input = new FileInputStream(propFile)) {
            prop.load(input);
        } catch (IOException ex) {
            logger.error("Properties file not recordsProcessed: {}", () -> propFile);
        }
        return prop;
    }

    private void getCollectionKeys() throws UnsupportedEncodingException {
        setLogLevel();
        if (db == null)
            initDB();

        Set<String> mySet = new HashSet<>();
        try (MongoCursor<Document> cursor = db.getCollection("personnel-assigned").find().iterator()) {
            while (cursor.hasNext()) {
                mySet.addAll(cursor.next().keySet());
            }
        }
        mySet.forEach(entry -> {
            logger.debug("KEY: {}", entry);
        });
    }


    public static void main(String[] argv) throws JAXBException, IOException, NoSuchFieldException, IllegalAccessException {
        Instant start = Instant.now();
        logger.info("A2T AOS START");
        ParseAOS parse = new ParseAOS();

        if (argv.length > 0)
            parse.runImport();
        else
            parse.getCollectionKeys();

        logger.info("A2T AOS FINISHED - seconds: {}, Documents Processed: {}",
                () -> (Duration.between(start, Instant.now()).toMillis() / 1000), () -> totalRecordsProcessed);
        exit(0);
    }

}